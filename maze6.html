<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Maze Explorer — Smooth One-Step with Timer</title>
<style>
  body { margin: 0; overflow: hidden; background: #111; color: #fff; font-family: sans-serif;}
  canvas { display: block; }
  #timer { position: absolute; top: 10px; left: 10px; font-size: 24px; }
</style>
</head>
<body>
<div id="timer">Time: 0.00s</div>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const mazeSize = 100;
const cellSize = 20;
const viewRange = 10;
const miniMapSize = 200;

let maze = [];
let player = {x: 1, y: 1};
let playerPos = {x: 1, y: 1};
let flag = {x: mazeSize - 2, y: mazeSize - 2};
let moving = false;
let moveTarget = null;
const moveSpeed = 0.2;

// 計時器
let startTime = Date.now();
let elapsed = 0;
const timerDiv = document.getElementById("timer");

function generateMaze(size) {
  let maze = Array.from({length: size}, () => Array(size).fill(1));
  function carve(x,y){
    maze[y][x] = 0;
    const dirs=[[0,-2],[0,2],[-2,0],[2,0]].sort(()=>Math.random()-0.5);
    for(const [dx,dy] of dirs){
      const nx=x+dx, ny=y+dy;
      if(nx>0&&nx<size-1 && ny>0&&ny<size-1 && maze[ny][nx]===1){
        maze[y+dy/2][x+dx/2]=0;
        carve(nx,ny);
      }
    }
  }
  carve(1,1);
  return maze;
}

function newMaze() {
  maze = generateMaze(mazeSize);
  player = {x:1, y:1};
  playerPos = {x:1, y:1};
  flag = {x: mazeSize - 2, y: mazeSize - 2};
  startTime = Date.now(); // 重置計時器
}

newMaze();

document.addEventListener("keydown", e=>{
  if(moving) return;
  let nx=player.x, ny=player.y;
  if(e.key==="w" || e.key==="ArrowUp") ny--;
  else if(e.key==="s" || e.key==="ArrowDown") ny++;
  else if(e.key==="a" || e.key==="ArrowLeft") nx--;
  else if(e.key==="d" || e.key==="ArrowRight") nx++;
  else return;

  if(maze[ny] && maze[ny][nx]===0){
    player.x=nx;
    player.y=ny;
    moveTarget={x:nx, y:ny};
    moving=true;
  }

  if(player.x===flag.x && player.y===flag.y){
    setTimeout(newMaze, 300);
  }
});

function update() {
  // 更新計時器
  elapsed = (Date.now() - startTime)/1000;
  timerDiv.innerText = "Time: " + elapsed.toFixed(2) + "s";

  if(moving && moveTarget){
    let dx = moveTarget.x - playerPos.x;
    let dy = moveTarget.y - playerPos.y;
    if(Math.abs(dx)<0.01 && Math.abs(dy)<0.01){
      playerPos.x = moveTarget.x;
      playerPos.y = moveTarget.y;
      moving = false;
      moveTarget = null;
    } else {
      playerPos.x += dx*moveSpeed;
      playerPos.y += dy*moveSpeed;
    }
  }
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  let startX = Math.max(0, Math.floor(playerPos.x) - viewRange);
  let endX = Math.min(mazeSize, Math.floor(playerPos.x) + viewRange);
  let startY = Math.max(0, Math.floor(playerPos.y) - viewRange);
  let endY = Math.min(mazeSize, Math.floor(playerPos.y) + viewRange);

  let viewWidth = (endX - startX)*cellSize;
  let viewHeight = (endY - startY)*cellSize;
  let offsetX = (canvas.width - viewWidth)/2;
  let offsetY = (canvas.height - viewHeight)/2;

  for(let y=startY; y<endY; y++){
    for(let x=startX; x<endX; x++){
      if(maze[y][x]===1){
        ctx.fillStyle="#333";
        ctx.fillRect(offsetX+(x-startX)*cellSize, offsetY+(y-startY)*cellSize, cellSize, cellSize);
      }
    }
  }

  ctx.fillStyle="cyan";
  ctx.fillRect(offsetX+(playerPos.x-startX)*cellSize, offsetY+(playerPos.y-startY)*cellSize, cellSize, cellSize);

  ctx.fillStyle="yellow";
  ctx.fillRect(offsetX+(flag.x-startX)*cellSize, offsetY+(flag.y-startY)*cellSize, cellSize, cellSize);

  // 小地圖
  let miniCell = miniMapSize / mazeSize;
  ctx.fillStyle="rgba(0,0,0,0.6)";
  ctx.fillRect(canvas.width-miniMapSize-10,10,miniMapSize,miniMapSize);
  for(let y=0;y<mazeSize;y++){
    for(let x=0;x<mazeSize;x++){
      if(maze[y][x]===1){
        ctx.fillStyle="#666";
        ctx.fillRect(canvas.width-miniMapSize-10 + x*miniCell, 10 + y*miniCell, miniCell, miniCell);
      }
    }
  }
  ctx.fillStyle="cyan";
  ctx.fillRect(canvas.width-miniMapSize-10 + playerPos.x*miniCell, 10 + playerPos.y*miniCell, miniCell, miniCell);
  ctx.fillStyle="yellow";
  ctx.fillRect(canvas.width-miniMapSize-10 + flag.x*miniCell, 10 + flag.y*miniCell, miniCell, miniCell);
}

function loop(){
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
